<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>quickstart</title>



</head>

<body>

<h1 id="toc_0">3 minute quickstart guide</h1>

<p>This short guide will have you downloading Unison, running your first program (a toy distributed mergesort implementation), and publishing your first definition. The focus here is on getting you up and running as quickly as possible. üèé More in-depth guides follow this one.</p>

<p>If you have any trouble with the process or ideas about how to improve this document, <a href="todo">come talk to us in Slack</a>! Also this document is <a href="todo">on GitHub</a>.</p>

<h3 id="toc_1">Step 1: Download Unison</h3>

<p>Download the <code>unison</code> executable for <a href="todo">Mac</a>, <a href="todo">Linux</a>, or <a href="todo">Windows</a> and then (optional) add it to your path.</p>

<h3 id="toc_2">Step 2: Create your Unison codebase</h3>

<p>Create a new directory, <code>unisoncode</code> (or any name you choose), then run the <code>unison</code> binary from within that directory. You&#39;ll see a note about &quot;No codebase exists here so I&#39;m initializing one...&quot; and a welcome screen.</p>

<script id="asciicast-IYWfFwIgyl9Gilk3ZExvLfOjg" src="https://asciinema.org/a/IYWfFwIgyl9Gilk3ZExvLfOjg.js" data-speed="2" data-cols="65" async></script>

<h3 id="toc_3">Step 3: Fetch and run a distributed mergesort example</h3>

<p>At the Unison <code>.&gt;</code> prompt, do <code>pull git@github.com:unisonweb/unisonbase.git</code> to fetch a base library with the example you&#39;ll be running. You&#39;ll see some output from <code>git</code> in the background, and once that&#39;s done you can do <code>edit quickstart.dsort</code> to add the <code>dsort</code> distributed mergesort function to the top of a newly created <em>scratch file</em>, <code>scratch.u</code>:</p>

<script id="asciicast-o9lfrfetnmUT4ArqdDFMXZkr9" src="https://asciinema.org/a/o9lfrfetnmUT4ArqdDFMXZkr9.js" data-speed="2" data-rows="30" data-cols="65" async></script>

<p>Open that file and add the following <em>watch expression</em> (a line starting with <code>&gt;</code>) to the top, then save the file:</p>

<div><pre><code class="language-none">&gt; runLocal &#39;(quickstart.dsort (&lt;) [8,2,3,1,4,5,6,7])</code></pre></div>

<script id="asciicast-aTn8qIa3DHaxhspsZJmXodfO7" src="https://asciinema.org/a/aTn8qIa3DHaxhspsZJmXodfO7.js" data-speed="2" async></script>

<p>You should see your watch expression evaluate to a sorted list.  <em>Disclaimer:</em> This example is just a toy that simulates execution locally and does no error handling, but it shows the general idea of being able to test Unison distributed programs locally (perhaps with simulated latency and failures injected) and then run the same programs unchanged atop an actual elastic source of distributed compute!</p>

<h3 id="toc_4">Step 4: Publishing your first definition</h3>

<p>Let&#39;s try publishing some code. First, fork the Unison base library, using the button below. This creates a valid minimal Unison codebase repo that you can push to:</p>

<iframe src="https://ghbtns.com/github-btn.html?user=unisonweb&repo=unisonbase&type=fork&count=true&size=large" frameborder="0" scrolling="0" width="158px" height="30px"></iframe>

<p>Then add the following to the top of your <code>scratch.u</code> file and save:</p>

<div><pre><code class="language-Haskell">firstlibrary.frobnicate x = x * 2

--- include this too, it&#39;s called &quot;the fold&quot;</code></pre></div>

<p>Include that <code>---</code> at the end to ignore the <code>dsort</code> definition below (or you can delete the <code>dsort</code> definition - you can always get it back via <code>edit</code>). Then from the <code>unison</code> prompt:</p>

<div><pre><code class="language-none">.&gt; add
.&gt; push git@github.com:&lt;your-githubusername&gt;/unisonbase.git</code></pre></div>

<p>Code is published just by being pushed to GitHub; there&#39;s no extra publication step. Others can use any namespace of definitions you&#39;ve published just using <code>pull</code>. We&#39;ll cover how more about how library publishing and upgrades work in detail in a later guide, but the process of installing a new namespace of definitions looks like:</p>

<div><pre><code class="language-none">.&gt; pull git@github.com:&lt;github-username&gt;/unisonbase.git install
.&gt; move.path install.firstlibrary awesomelibrary
.&gt; delete.path install</code></pre></div>

<p>And then <code>awesomelibrary.frobnicate</code> will be resolved to the <code>frobnicate</code> definition you published.</p>

<h3 id="toc_5">What next?</h3>

<ul>
<li>Come <a href="todo">say hello in Slack</a>, tell us what you thought about this guide, and ask questions. üëã</li>
<li>A <a href="todo">more leisurely guide</a> to the Unison language and the <code>unison</code> command line tool. (25 minutes)</li>
</ul>




</body>

</html>
